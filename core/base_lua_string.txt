"BASE_ARBIBOARD = {}\n"
"BASE_ARBIBOARD._modified_tables = {{}}\n"
"BASE_ARBIBOARD._save_history = false\n"
"BASE_ARBIBOARD._history = {}\n"
"BASE_ARBIBOARD._transaction_layer = 1\n"
"\n"
"\n"
"function BASE_ARBIBOARD.createGameObject()\n"
"    local data = {}\n"
"    local transactions = {}\n"
"\n"
"    local mt = {\n"
"        __index = function(_, key)\n"
"            return data[key]\n"
"        end,\n"
"        __newindex = function(t, key, value)\n"
"            if type(value) == \"table\" then\n"
"                if value.BASE_METHOD_commit_changes == nil then\n"
"                    error(\"Attempted to assign a plain Lua table to key '\" .. tostring(key) ..\n"
"                            \"' in a tracked gameobject. Only gameobjects are allowed.\", 2)\n"
"                end\n"
"            end\n"
"            BASE_ARBIBOARD._modified_tables[BASE_ARBIBOARD._transaction_layer][t] = t\n"
"            local current_transaction = transactions[BASE_ARBIBOARD._transaction_layer]\n"
"            if current_transaction == nil then\n"
"                current_transaction = {\n"
"                    modified = {},\n"
"                    added = {},\n"
"                    removed = {}\n"
"                }\n"
"                transactions[BASE_ARBIBOARD._transaction_layer] = current_transaction\n"
"            end\n"
"            if data[key] == nil and value ~= nil then\n"
"                if not current_transaction.added[key] and not current_transaction.removed[key] then\n"
"                    current_transaction.added[key] = value\n"
"                elseif current_transaction.removed[key] then\n"
"                    current_transaction.modified[key] = current_transaction.removed[key]\n"
"                    current_transaction.removed[key] = nil\n"
"                end\n"
"            elseif data[key] ~= nil and value == nil then\n"
"                if current_transaction.added[key] then\n"
"                    current_transaction.added[key] = nil\n"
"                else\n"
"                    current_transaction.modified[key] = nil\n"
"                    current_transaction.removed[key] = data[key]\n"
"                end\n"
"            elseif data[key] ~= value then\n"
"                if not current_transaction.added[key] then\n"
"                    if current_transaction.removed[key] ~= nil then\n"
"                        current_transaction.modified[key] = current_transaction.removed[key]\n"
"                        current_transaction.removed[key] = nil\n"
"                    elseif current_transaction.modified[key] == nil then\n"
"                        current_transaction.modified[key] = data[key]\n"
"                    end\n"
"                else\n"
"                    current_transaction.added[key] = value\n"
"                end\n"
"            end\n"
"            data[key] = value\n"
"        end,\n"
"        __pairs = function(t)\n"
"            return next, data, nil\n"
"        end,\n"
"        __metatable = {\n"
"            commit_changes = function()\n"
"                local current_transaction = transactions[BASE_ARBIBOARD._transaction_layer]\n"
"                if current_transaction then\n"
"                    local previous_transaction = {\n"
"                    modified = {},\n"
"                    added = {},\n"
"                    removed = {}\n"
"                    }\n"
"                    local transaction_layer = BASE_ARBIBOARD._transaction_layer - 1\n"
"                    if transactions[transaction_layer] ~= nil then\n"
"                        previous_transaction = transactions[transaction_layer]\n"
"                    end\n"
"                    for k, v in pairs(current_transaction.removed) do\n"
"                        if previous_transaction.added[k] ~= nil then\n"
"                            previous_transaction.added[k] = nil\n"
"                        else\n"
"                            previous_transaction.removed[k] = v\n"
"                            previous_transaction.modified[k] = nil\n"
"                        end\n"
"                    end\n"
"                    for k, v in pairs(current_transaction.modified) do\n"
"                        if previous_transaction.added[k] ~= nil then\n"
"                            previous_transaction.added[k] = v\n"
"                        end\n"
"                    end\n"
"                    for k, v in pairs(current_transaction.added) do\n"
"                        if previous_transaction.removed[k] ~= nil then\n"
"                            previous_transaction.modified[k] = previous_transaction.removed[k]\n"
"                            previous_transaction.removed[k] = nil\n"
"                        else\n"
"                            previous_transaction.added[k] = v\n"
"                        end\n"
"                    end\n"
"                    transactions[BASE_ARBIBOARD._transaction_layer] = nil\n"
"\n"
"                end\n"
"            end,\n"
"            restore = function()\n"
"                local current_transaction = transactions[BASE_ARBIBOARD._transaction_layer]\n"
"                if current_transaction then\n"
"                    for k, v in pairs(current_transaction.removed) do\n"
"                        data[k] = v\n"
"                    end\n"
"                    for k, v in pairs(current_transaction.modified) do\n"
"                        data[k] = v\n"
"                    end\n"
"                    for k, v in pairs(current_transaction.added) do\n"
"                        data[k] = nil\n"
"                    end\n"
"                    transactions[BASE_ARBIBOARD._transaction_layer] = nil\n"
"\n"
"                end\n"
"            end\n"
"        }\n"
"    }\n"
"\n"
"    local proxy = {}\n"
"\n"
"    function proxy:BASE_METHOD_commit_changes()\n"
"        mt.__metatable.commit_changes()\n"
"        BASE_ARBIBOARD._modified_tables[BASE_ARBIBOARD._transaction_layer][proxy] = nil\n"
"    end\n"
"\n"
"    function proxy:BASE_METHOD_restore()\n"
"        mt.__metatable.restore()\n"
"        BASE_ARBIBOARD._modified_tables[BASE_ARBIBOARD._transaction_layer][proxy] = nil\n"
"    end\n"
"\n"
"    setmetatable(proxy, mt)\n"
"    proxy.commit_changes()\n"
"    return proxy\n"
"end\n"
"\n"
"function BASE_ARBIBOARD.commit_all_tables()\n"
"\n"
"    local step_history = {}\n"
"    if BASE_ARBIBOARD._transaction_layer == 1 and BASE_ARBIBOARD._save_history then\n"
"        table.insert(BASE_ARBIBOARD._history, step_history)\n"
"    end\n"
"    for k, v in pairs(BASE_ARBIBOARD._modified_tables[BASE_ARBIBOARD._transaction_layer]) do\n"
"        if BASE_ARBIBOARD._transaction_layer == 1 and BASE_ARBIBOARD._save_history then\n"
"            local object_changes = {}\n"
"            object_changes.removed = v.BASE_METHOD_list_removed\n"
"            object_changes.added = v.BASE_METHOD_list_added\n"
"            object_changes.modified = v.BASE_METHOD_list_modified\n"
"            step_history[k] = object_changes\n"
"        end\n"
"        v.BASE_METHOD_commit_changes()\n"
"    end\n"
"    BASE_ARBIBOARD._modified_tables[BASE_ARBIBOARD._transaction_layer] = {}\n"
"end\n"
"\n"
"\n"
"function BASE_ARBIBOARD.restore_all_tables()\n"
"    for k, v in pairs(BASE_ARBIBOARD._modified_tables[BASE_ARBIBOARD._transaction_layer]) do\n"
"        v.BASE_METHOD_restore()\n"
"    end\n"
"    BASE_ARBIBOARD._modified_tables[BASE_ARBIBOARD._transaction_layer] = {}\n"
"end\n"
"\n"
"function BASE_ARBIBOARD.move(request)\n"
"    if type(API) ~= \"table\" then\n"
"        error(\"ERROR FROM BASE SCRIPT: API table is not defined\")\n"
"    end\n"
"    if type(API.move) ~= \"function\" then\n"
"        error(\"ERROR FROM BASE SCRIPT: API.move function is not defined. It should be defined in API script.\")\n"
"    end\n"
"    local success, message = API.move(request)\n"
"    if type(success) == \"boolean\" and type(message) == \"string\" then\n"
"        if success then\n"
"            BASE_ARBIBOARD.commit_all_tables()\n"
"        else\n"
"            BASE_ARBIBOARD.restore_all_tables()\n"
"        end\n"
"        return success, message\n"
"    else\n"
"        error(string.format(\"ERROR FROM BASE SCRIPT: Invalid return types from API.move function in API script: expected (boolean, string) but got (%s, %s)\", type(success), type(message)))\n"
"    end\n"
"end\n"
"\n"
"function BASE_ARBIBOARD.init(request, history)\n"
"    if type(API) ~= \"table\" then\n"
"        error(\"ERROR FROM BASE SCRIPT: API table is not defined\")\n"
"    end\n"
"    if type(API.init) ~= \"function\" then\n"
"        error(\"ERROR FROM BASE SCRIPT: API.init function is not defined. It should be defined in API script.\")\n"
"    end\n"
"    BASE_ARBIBOARD._save_history = history\n"
"    local message = API.init(request)\n"
"    BASE_ARBIBOARD.commit_all_tables()\n"
"    if type(message) == \"string\" then\n"
"        return message\n"
"    else\n"
"        error(string.format(\"ERROR FROM BASE SCRIPT: Invalid return type from API.init function in API script: %s\", type(message)))\n"
"    end\n"
"end\n"
"\n"
"function BASE_ARBIBOARD.query(requests)\n"
"    local responses = {}\n"
"    if type(API) ~= \"table\" then\n"
"        error(\"ERROR FROM BASE SCRIPT: API table is not defined\")\n"
"    end\n"
"    if type(API.query) ~= \"function\" then\n"
"        error(\"ERROR FROM BASE SCRIPT: API.query function is not defined. It should be defined in API script.\")\n"
"    end\n"
"    for i, request in ipairs(requests) do\n"
"        local success, message = API.query(request)\n"
"        if type(success) == \"boolean\" and type(message) == \"string\" then\n"
"            table.insert(responses, {[\"request\"] = request, [\"message\"] = message, [\"success\"] = success})\n"
"            if not success then\n"
"                break\n"
"            end\n"
"        else\n"
"            error(string.format(\"ERROR FROM BASE SCRIPT: Invalid return type from API.query function in API script: %s\", type(message)))\n"
"        end\n"
"\n"
"    end\n"
"    BASE_ARBIBOARD.restore_all_tables()\n"
"    return responses\n"
"end\n"
"\n"
"function BASE_ARBIBOARD._simulate_moves(init, requests)\n"
"    BASE_ARBIBOARD._transaction_layer = BASE_ARBIBOARD._transaction_layer + 1\n"
"    BASE_ARBIBOARD._modified_tables[BASE_ARBIBOARD._transaction_layer] = {}\n"
"    init()\n"
"    local responses = {}\n"
"    for i, v in ipairs(requests) do\n"
"        local success, message = API.move(request)\n"
"        table.insert(responses, {[\"request\"] = v, [\"message\"] = message, [\"success\"] = success})\n"
"        if not success then\n"
"            BASE_ARBIBOARD.restore_all_tables()\n"
"            break\n"
"        end\n"
"    end\n"
"    return responses\n"
"end\n"
"\n"
"function BASE_ARBIBOARD.simulate_moves(init, requests)\n"
"    local responses = BASE_ARBIBOARD._simulate_moves(init, requests)\n"
"    BASE_ARBIBOARD.restore_all_tables()\n"
"    BASE_ARBIBOARD._modified_tables[BASE_ARBIBOARD._transaction_layer] = nil\n"
"    BASE_ARBIBOARD._transaction_layer = BASE_ARBIBOARD._transaction_layer - 1\n"
"    return responses\n"
"\n"
"end\n"
"\n"
"function BASE_ARBIBOARD.try_moves(init, requests)\n"
"    local responses = BASE_ARBIBOARD._simulate_moves(init, requests)\n"
"    BASE_ARBIBOARD.commit_all_tables()\n"
"    BASE_ARBIBOARD._modified_tables[BASE_ARBIBOARD._transaction_layer] = nil\n"
"    BASE_ARBIBOARD._transaction_layer = BASE_ARBIBOARD._transaction_layer - 1\n"
"    return responses\n"
"end"